import React from 'react';
import { Document, Page, Text, View } from '@react-pdf/renderer';
import { renderToBuffer } from '@react-pdf/renderer';
import { AccountingError } from '../errors';
import type { ProfitLossReport, ReportLineItem } from '../services/report.service';
import {
  reportStyles as s,
  truncate,
  formatCentsForPdf,
  formatDateForPdf,
  countLineItems,
  PDF_MAX_ENTRIES,
  PDF_TIMEOUT_MS,
} from './shared-styles';

/**
 * Generate Profit & Loss Statement PDF
 *
 * Protective limits:
 * - Max 1000 line items (recommend CSV for larger reports)
 * - 30s generation timeout
 * - User-supplied strings truncated
 */
export async function generateProfitLossPdf(report: ProfitLossReport): Promise<Buffer> {
  const allItems = [...(report.revenue?.sections || []), ...(report.expenses?.sections || [])];
  const lineItemCount = countLineItems(allItems);

  if (lineItemCount > PDF_MAX_ENTRIES) {
    throw new AccountingError(
      `Report too large for PDF export (${lineItemCount} entries exceed ${PDF_MAX_ENTRIES} limit). Use CSV export instead.`,
      'PDF_TOO_LARGE',
      400
    );
  }

  let timeoutHandle: ReturnType<typeof setTimeout>;
  const timeoutPromise = new Promise<never>((_, reject) => {
    timeoutHandle = setTimeout(() => reject(new AccountingError('PDF generation timed out', 'PDF_TIMEOUT', 408)), PDF_TIMEOUT_MS);
  });

  const pdfDoc = (
    <Document>
      <Page size="A4" style={s.page}>
        {/* Header */}
        <View style={s.header}>
          <Text style={s.headerTitle}>Profit &amp; Loss Statement</Text>
          <Text style={s.headerSubtitle}>{truncate(report.entityName, 100)}</Text>
          <Text style={s.headerDate}>
            {formatDateForPdf(report.startDate)} to {formatDateForPdf(report.endDate)}
          </Text>
          <Text style={s.headerDate}>Currency: {report.currency}</Text>
        </View>

        {/* Revenue Section */}
        <View>
          <Text style={s.sectionHeader}>Revenue</Text>
          <LineItems items={report.revenue?.sections || []} currency={report.currency} />
          <View style={s.totalRow}>
            <Text style={s.totalLabel}>Total Revenue</Text>
            <Text style={s.totalValue}>{formatCentsForPdf(report.revenue?.total || 0, report.currency)}</Text>
          </View>
        </View>

        {/* Expenses Section */}
        <View>
          <Text style={s.sectionHeader}>Expenses</Text>
          <LineItems items={report.expenses?.sections || []} currency={report.currency} />
          <View style={s.totalRow}>
            <Text style={s.totalLabel}>Total Expenses</Text>
            <Text style={s.totalValue}>{formatCentsForPdf(report.expenses?.total || 0, report.currency)}</Text>
          </View>
        </View>

        {/* Net Income */}
        <View style={s.grandTotalRow}>
          <Text style={s.grandTotalLabel}>Net Income</Text>
          <Text style={s.grandTotalValue}>{formatCentsForPdf(report.netIncome, report.currency)}</Text>
        </View>

        {/* Footer */}
        <View style={s.footer} fixed>
          <Text style={s.footerText}>Generated by Akount on {new Date().toLocaleDateString('en-CA')}</Text>
          <Text style={s.footerText}>Confidential</Text>
        </View>
      </Page>
    </Document>
  );

  try {
    const buffer = await Promise.race([
      renderToBuffer(pdfDoc),
      timeoutPromise,
    ]);
    return Buffer.from(buffer);
  } finally {
    clearTimeout(timeoutHandle!);
  }
}

function LineItems({ items, currency }: { items: ReportLineItem[]; currency: string }) {
  return (
    <View>
      {items.map((item, idx) => (
        <View key={idx} style={[s.row, { paddingLeft: 4 + item.depth * 12 }]}>
          <Text style={[s.rowLabel, item.isSubtotal ? { fontFamily: 'Helvetica-Bold' } : {}]}>
            {truncate(item.code, 10)} - {truncate(item.name, 60)}
          </Text>
          <Text style={s.rowValue}>{formatCentsForPdf(item.balance, currency)}</Text>
        </View>
      ))}
    </View>
  );
}
