#!/usr/bin/env node

/**
 * Regenerate Decision Index
 *
 * Scans .claude/decisions/*.md and generates searchable INDEX.md
 * Also creates decisions-by-file.json for code index integration
 */

const fs = require('fs');
const path = require('path');

const DECISIONS_DIR = '.claude/decisions';
const INDEX_FILE = path.join(DECISIONS_DIR, 'INDEX.md');
const BY_FILE_OUTPUT = path.join(DECISIONS_DIR, 'decisions-by-file.json');

/**
 * Parse decision file frontmatter/headers
 */
function parseDecision(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');
  const fileName = path.basename(filePath);

  // Extract title (first # heading)
  const titleMatch = content.match(/^# (.+)$/m);
  const title = titleMatch ? titleMatch[1] : fileName.replace('.md', '');

  // Extract metadata (Date, Tags, Status, Files Affected)
  const dateMatch = content.match(/\*\*Date:\*\* (.+)/);
  const tagsMatch = content.match(/\*\*Tags:\*\* (.+)/);
  const statusMatch = content.match(/\*\*Status:\*\* (.+)/);
  const filesMatch = content.match(/## Files Affected\n\n([\s\S]*?)(?=\n##|\n---|\n_Created:)/);

  const date = dateMatch ? dateMatch[1] : 'Unknown';
  const tags = tagsMatch ? tagsMatch[1].split(',').map(t => t.trim()) : [];
  const status = statusMatch ? statusMatch[1] : 'Active';

  // Parse files affected section
  const files = [];
  if (filesMatch) {
    const fileLines = filesMatch[1].split('\n').filter(l => l.trim().startsWith('-'));
    fileLines.forEach(line => {
      const fileMatch = line.match(/`([^`]+)`/);
      if (fileMatch) {
        files.push(fileMatch[1]);
      }
    });
  }

  return {
    id: fileName.replace('.md', ''),
    title,
    date,
    tags,
    status,
    files,
    fileName,
  };
}

/**
 * Generate markdown index table
 */
function generateIndexMarkdown(decisions) {
  const lines = [];

  lines.push('# Decision Index');
  lines.push('');
  lines.push('_Auto-generated by `regenerate-decision-index.js` â€” do not edit manually_');
  lines.push('');
  lines.push(`**Last Updated:** ${new Date().toISOString().split('T')[0]}`);
  lines.push(`**Total Decisions:** ${decisions.length}`);
  lines.push('');
  lines.push('---');
  lines.push('');
  lines.push('## All Decisions');
  lines.push('');
  lines.push('| Date | Decision | Tags | Status | Files |');
  lines.push('|------|----------|------|--------|-------|');

  // Sort by date (newest first)
  const sorted = [...decisions].sort((a, b) => b.date.localeCompare(a.date));

  sorted.forEach(d => {
    const tagsStr = d.tags.join(', ');
    const filesCount = d.files.length > 0 ? `${d.files.length} files` : 'â€”';
    const link = `[${d.title}](./${d.fileName})`;
    lines.push(`| ${d.date} | ${link} | ${tagsStr} | ${d.status} | ${filesCount} |`);
  });

  lines.push('');
  lines.push('---');
  lines.push('');

  // Group by tag
  lines.push('## By Tag');
  lines.push('');

  const byTag = {};
  decisions.forEach(d => {
    d.tags.forEach(tag => {
      if (!byTag[tag]) byTag[tag] = [];
      byTag[tag].push(d);
    });
  });

  Object.keys(byTag).sort().forEach(tag => {
    lines.push(`### ${tag}`);
    lines.push('');
    byTag[tag].forEach(d => {
      lines.push(`- [${d.title}](./${d.fileName}) (${d.date})`);
    });
    lines.push('');
  });

  lines.push('---');
  lines.push('');
  lines.push('## By File');
  lines.push('');

  const byFile = {};
  decisions.forEach(d => {
    d.files.forEach(file => {
      if (!byFile[file]) byFile[file] = [];
      byFile[file].push(d);
    });
  });

  const sortedFiles = Object.keys(byFile).sort();
  if (sortedFiles.length > 0) {
    sortedFiles.forEach(file => {
      lines.push(`### ${file}`);
      lines.push('');
      byFile[file].forEach(d => {
        lines.push(`- [${d.title}](./${d.fileName}) (${d.date})`);
      });
      lines.push('');
    });
  } else {
    lines.push('_No file mappings yet._');
    lines.push('');
  }

  lines.push('---');
  lines.push('');
  lines.push('_Run `node .claude/scripts/regenerate-decision-index.js` to rebuild this index._');

  return lines.join('\n');
}

/**
 * Generate decisions-by-file.json for code index integration
 */
function generateFileMapping(decisions) {
  const mapping = {};

  decisions.forEach(d => {
    d.files.forEach(file => {
      if (!mapping[file]) mapping[file] = [];
      mapping[file].push({
        id: d.id,
        title: d.title,
        date: d.date,
        tags: d.tags,
      });
    });
  });

  return mapping;
}

/**
 * Main execution
 */
function regenerateIndex() {
  if (!fs.existsSync(DECISIONS_DIR)) {
    console.error('Error: .claude/decisions/ directory not found');
    process.exit(1);
  }

  // Read all decision files (exclude README, TEMPLATE, INDEX)
  const files = fs.readdirSync(DECISIONS_DIR)
    .filter(f => f.endsWith('.md'))
    .filter(f => !['README.md', 'TEMPLATE.md', 'INDEX.md'].includes(f))
    .map(f => path.join(DECISIONS_DIR, f));

  if (files.length === 0) {
    console.log('No decision files found. INDEX.md left as placeholder.');
    return;
  }

  console.log(`ðŸ“‹ Found ${files.length} decision file(s)`);

  // Parse all decisions
  const decisions = files.map(parseDecision);

  // Generate index
  const indexMarkdown = generateIndexMarkdown(decisions);
  fs.writeFileSync(INDEX_FILE, indexMarkdown, 'utf-8');
  console.log(`âœ… Generated INDEX.md with ${decisions.length} decisions`);

  // Generate file mapping
  const fileMapping = generateFileMapping(decisions);
  fs.writeFileSync(BY_FILE_OUTPUT, JSON.stringify(fileMapping, null, 2), 'utf-8');
  console.log(`âœ… Generated decisions-by-file.json with ${Object.keys(fileMapping).length} file mappings`);

  // Stats
  const tagCount = new Set(decisions.flatMap(d => d.tags)).size;
  console.log('');
  console.log('ðŸ“Š Summary:');
  console.log(`   Decisions: ${decisions.length}`);
  console.log(`   Tags: ${tagCount}`);
  console.log(`   Files: ${Object.keys(fileMapping).length}`);
}

// Main execution
try {
  regenerateIndex();
} catch (error) {
  console.error('Error generating decision index:', error);
  process.exit(1);
}

module.exports = { parseDecision, generateIndexMarkdown, generateFileMapping };
