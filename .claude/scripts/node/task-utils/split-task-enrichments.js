#!/usr/bin/env node

/**
 * Split task-enrichments.json into domain-based files
 *
 * Usage: node split-task-enrichments.js
 */

const fs = require('fs');
const path = require('path');
const { getProjectRoot } = require('../../lib/project-root');

const PROJECT_ROOT = getProjectRoot(__dirname);
const OLD_FILE = path.join(PROJECT_ROOT, '.claude/task-enrichments.json');
const OUTPUT_DIR = path.join(PROJECT_ROOT, '.claude/state/task-enrichments');

// Domain mapping by task ID prefix
const DOMAIN_MAP = {
  // Banking
  BANK: 'banking',

  // Invoicing & Business
  INV: 'invoicing',
  BILL: 'invoicing',
  CLI: 'invoicing',
  VEN: 'invoicing',
  PAY: 'invoicing',

  // Accounting
  ACC: 'accounting',
  GL: 'accounting',
  JE: 'accounting',
  TAX: 'accounting',

  // Planning
  PLAN: 'planning',
  BUDG: 'planning',
  FCST: 'planning',
  GOAL: 'planning',

  // AI & Insights
  AI: 'ai',
  INS: 'ai',
  RULE: 'ai',
  CAT: 'ai',

  // Web/UI
  UX: 'web',
  UI: 'web',
  FE: 'web',

  // Cross-cutting (Security, Performance, Infrastructure, Testing, etc.)
  SEC: 'cross-cutting',
  PERF: 'cross-cutting',
  INFRA: 'cross-cutting',
  TEST: 'cross-cutting',
  DEV: 'cross-cutting',  // Default for DEV-* tasks
  ARCH: 'cross-cutting',
  DRY: 'cross-cutting',
  FIN: 'cross-cutting',
};

// Infer domain from task ID
function inferDomain(taskId) {
  // Extract prefix (before hyphen or first digit)
  const match = taskId.match(/^([A-Z]+)/);
  if (!match) return 'cross-cutting';

  const prefix = match[1];

  // Direct match
  if (DOMAIN_MAP[prefix]) {
    return DOMAIN_MAP[prefix];
  }

  // Check if it starts with any mapped prefix
  for (const [key, domain] of Object.entries(DOMAIN_MAP)) {
    if (prefix.startsWith(key)) {
      return domain;
    }
  }

  // For DEV-* tasks, try to infer from file paths
  if (taskId.startsWith('DEV-')) {
    // Will be refined by checkFiles() below
    return 'cross-cutting';
  }

  // Default
  return 'cross-cutting';
}

// Refine domain based on file paths in enrichment
function refineDomain(taskId, enrichment, initialDomain) {
  if (!enrichment.files || enrichment.files.length === 0) {
    return initialDomain;
  }

  const paths = enrichment.files.join(' ');

  // Check for domain-specific paths
  if (paths.includes('/banking/')) return 'banking';
  if (paths.includes('/invoicing/') || paths.includes('/clients/') || paths.includes('/vendors/')) return 'invoicing';
  if (paths.includes('/accounting/')) return 'accounting';
  if (paths.includes('/planning/')) return 'planning';
  if (paths.includes('/ai/') || paths.includes('/insights/')) return 'ai';
  if (paths.includes('/web/') || paths.includes('/components/')) return 'web';

  return initialDomain;
}

function main() {
  console.log('ðŸ“¦ Splitting task-enrichments.json into domain files...\n');

  // Read old file
  if (!fs.existsSync(OLD_FILE)) {
    console.error(`âŒ File not found: ${OLD_FILE}`);
    process.exit(1);
  }

  const content = fs.readFileSync(OLD_FILE, 'utf-8');
  const enrichments = JSON.parse(content);

  // Remove $comment field
  const $comment = enrichments.$comment;
  delete enrichments.$comment;

  const taskIds = Object.keys(enrichments);
  console.log(`ðŸ“Š Found ${taskIds.length} task enrichments`);

  // Create output directory
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });

  // Split by domain
  const domainData = {
    banking: {},
    invoicing: {},
    accounting: {},
    planning: {},
    ai: {},
    web: {},
    'cross-cutting': {},
  };

  const index = {};

  for (const taskId of taskIds) {
    const enrichment = enrichments[taskId];
    let domain = inferDomain(taskId);
    domain = refineDomain(taskId, enrichment, domain);

    domainData[domain][taskId] = enrichment;
    index[taskId] = domain;
  }

  // Write domain files
  for (const [domain, data] of Object.entries(domainData)) {
    const count = Object.keys(data).length;
    if (count === 0) continue;

    const filename = `${domain}.json`;
    const filepath = path.join(OUTPUT_DIR, filename);

    fs.writeFileSync(filepath, JSON.stringify(data, null, 2), 'utf-8');
    console.log(`  âœ… ${filename} (${count} tasks)`);
  }

  // Write index file
  const indexPath = path.join(OUTPUT_DIR, 'index.json');
  const indexContent = {
    $comment: 'Master index mapping task IDs to domain files. Auto-generated by split-task-enrichments.js',
    ...index,
  };
  fs.writeFileSync(indexPath, JSON.stringify(indexContent, null, 2), 'utf-8');
  console.log(`  âœ… index.json (${taskIds.length} mappings)`);

  // Archive old file
  const archivePath = path.join(PROJECT_ROOT, '.claude/state/task-enrichments.OLD.json');
  const archiveContent = {
    $comment: `Archived on ${new Date().toISOString().split('T')[0]}. Split into domain files. See .claude/state/task-enrichments/`,
    ...enrichments,
  };
  fs.writeFileSync(archivePath, JSON.stringify(archiveContent, null, 2), 'utf-8');
  console.log(`  âœ… task-enrichments.OLD.json (archived)`);

  console.log('\nðŸ“Š Summary:');
  for (const [domain, data] of Object.entries(domainData)) {
    const count = Object.keys(data).length;
    if (count > 0) {
      console.log(`  ${domain}: ${count} tasks`);
    }
  }

  console.log('\nâœ… Split complete!');
  console.log(`\nNext steps:`);
  console.log(`  1. Update enrich-task.js to load from new structure`);
  console.log(`  2. Update score-task-risk.js to load from new structure`);
  console.log(`  3. Remove old .claude/task-enrichments.json`);
}

main();
